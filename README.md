# Orderbook
#Structures used in the design

In this design, the order book is represented by two arrays, one for sell orders and the other for buy orders. Both of them are stored separately for convenient access and matching. Each position of the arrays stores a struct corresponding to an order of a particular price point. This struct is the head of a linked list of all such structs of the outstanding orders with the same price point. These price points are always kept sorted in both the arrays with the best offer or best bid at the zeroeth position. The struct stores the price, quantity, a unique id for that order, and the pointer to the next struct in the linked list. We maintain 4 global variables, ‘ArraySellNo’ and ‘ArrayBuyNo’ for the number of sell/buy orders currently in the array, and ‘SellId’ and  ‘BuyId’ for the total sell/buy orders placed. This is used for assigning the unique id to every new order. Two maps, ‘Buy’ and ‘Sell’ are also defined. They match all the id numbers with the status of their respective orders. The status can be ‘pending’, ‘executed’, ‘converted’ or ‘canceled’. These maps are maintained so that we have a record of all the orders ever written in our order book, including the, converted, executed and canceled ones. 

#Solving the queries

Whenever a new limit sell order is entered, its limit is compared with the first position of the array of outstanding buy orders. If the price of the sell order is higher than that value, then the order is added to the array of outstanding sell orders. Else, we match it with the outstanding buy order which is closest to the limit of the sell order. For that, we traverse the buy orders till the last outstanding order which satisfies the limit of this sell order and start matching the buy orders backward till either the quantity of the sell order is exhausted or the buy orders. If the buy order is not exhausted, then the order of the remaining stocks is added to the array of outstanding sell orders.
 
To add the order in this array, we start traversing the array from the best offer to the position, where the price of the order is no longer smaller than the pricepoint corresponding to that position. If there exists a position, with pricepoint equal to the price of the sell order, the order is placed in that position of the array, and its pointer points to the struct previously present at that position. Otherwise, all the linked lists are shifted one position to the right to make a position for the new order. 

When a market sell order is placed, we just start matching it with the best bid from the outstanding buy orders until all the stocks of the order are exhausted. After an outstanding buy order is matched, it is removed from the order book by shifting all the orders after it, one position to their left. If in a case, which might not happen in practical application, there are no orders to match the market order, we print the number of stocks that are left to match.

This design also allows the trader to change his/her order's type from limit to market order at any point in time. To make this process convenient, we give every order a unique id number. To convert any order, the user has to input the id number of that order, and we search for the id linearly in the linked lists at every position of the array. We simply set the quantity of that order to zero, and call the function to execute the market order and assign this order a new id. 

Similarly, to cancel the order, we set the quantity of that order to zero and while traversing the linked lists, we ignore such orders. 

The queries corresponding to the buy orders are handled similarly.

After executing we choose to remove the orders from the order book because since billions of transactions take place in a day and if we do not remove them from the order book, not only will a lot of space be wasted, but also checking through all these zero-quantity already-executed orders for matching every new order would consume a lot of time. Hence we remove the executed orders in O(1) for orders in the linked lists and O(n) if it is the only order with that price point. 

#Choice of the data structure

To decide which data structure would give the most optimal solution, I considered both time complexity and space complexity of all these queries, giving higher priority to optimize the time complexity, keeping in mind the volatility of the prices and the scale of this implementation. I have tried to optimize the simplicity of the code, keeping it as simple as possible.   

The two best candidates for the data structure for this order book are an array and a min-heap/max-heap of structs(heads of the linked lists). The choice of the data structure to be an array was made based on two observations. Firstly, an array of a fixed size allows us to access memory locations directly, saving the costs of dynamically allocating memory for every new order. 

Now we see that the major operations we need to perform on these data structures are insertion, deletion, and search. Although in a min-heap/ max-heap, executing a market order will be O(lg(n)), solving the other queries will not be as straight forward as this. Deleting and converting would require going through the entire heap to match the Id. Hence that would take O(n). To match a limit order to the pricepoint closest to its price, we would have to go through all nodes of the heap in the worst case in O(n) and remove the node in O(lg(n)). When the new order is only partially executed, to look for every next outstanding order to match, the entire process would have to be followed in O(n).    

In arrays, this can be done in O(1) since we just have to move to the adjacent position as it is already sorted. Even though insertion, deletion, and searching would take linear time in arrays, the code should do well in the practical application. This is because, since in an order book, we are talking about stocks of the same company, the interval in which the prices should lie, will not be long. And since we are adding the orders at the same price points as branches in the form of a linked list, the number of elements in the array or the heap, that is distinct price points, will not be large. With the added simplicity of the code and execution, avoiding all the pointer manipulation costs to keep the structure sorted, we conclude, using arrays of structs, is the best choice for the order book.

#How is the matching done

For Market Order, we start matching it with the best bid/offer available in the order book. And for a limit order, we go to the outstanding bid/offer which last satisfies the limit of the new order and start matching towards the better bid/offer.  

If a new sell/buy order is entered, and its limit matches more than one outstanding buy/sell order at the same price point closest to the price limit of the sell/buy order, the algorithm prioritizes the orders based on the time at which the order was placed. It starts matching the sell/buy order from the oldest buy/sell order to the newer ones. It is done simply because it is only fair for the people who have placed their order earlier to get it executed first, no matter how many stocks he has offered or asked for. The other way such a situation could be managed is by distributing the stocks in proportion with the number of shares of each order. One disadvantage that I could see in distributing the stocks in this way, was the scope of traders misusing it. Traders could place orders with a quantity greater than what they actually want, driven with the greed of getting it executed faster, and cancel the rest of the order once their needs are met. Hence this implementation of the order book does justice by following the ‘first come first serve’ principle. 

This is the basic simplified idea of how the order book is going to function. For implementation in the real world, we might have to modify some parts of the design, keeping in mind the constraints of real world.
